# Домашка 3: Базы данных

## Разделение по сервисам

### 1. AUTH (аутентификация и авторизация)
Тип данных - учётные записи, пароли (в зашифрованном виде), токены, роли.

1. Выбираем PostgreSQL. Это реляционная БД, отлично подходящая для хранения пользователей и связей между ними.
2. Почему именно она: структура данных несложная, важна консистентность и безопасность. Масштабироваться пока не требуется.
3. Репликацию можно использовать для разгрузки при большом количестве логинов, а шардинг - по user_id, если сильно вырастем.

---

### 2. DOCS (работа с документами)
Храним метаданные документов, шаблоны, ссылки на файлы, версии.

1. Для метаданных используем PostgreSQL, а сами файлы складываем в object storage (например, S3 или MinIO).
2. Такой подход позволяет не перегружать БД тяжёлыми файлами, но при этом удобно фильтровать, сортировать и версионировать документы.
3. Репликация нужна для стабильной работы истории, а при росте - можно шардировать по user_id.

---

### 3. PRINT (задания на печать)
Сохраняем задания на печать, их статус, историю.

1. Тут тоже подойдёт PostgreSQL. Структура чёткая: кто, что, когда, куда отправил.
2. Важно не терять задания и не допускать дублей, поэтому надёжная транзакционная БД - must-have.
3. На старте достаточно одной ноды, позже - репликация для чтения и шардинг по user_id или ID копицентра.

---

### 4. COPY (копицентры)
Информация об отделениях, их расположении, статусе и возможностях.

1. Базу берём ту же - PostgreSQL. Объём данных небольшой, структура простая.
2. Главное - не потерять консистентность. Если салон недоступен, задание туда уйти не должно.
3. Шардинг не нужен, но можно сделать реплики на чтение.

---

### 5. Кеш (опционально)
Данные, к которым часто обращаются - шаблоны, статусы печати и отделений.

1. Для этого подходит Redis. Быстрый, лёгкий, key-value.
2. Используем для ускорения интерфейса и снижения нагрузки на основные сервисы.
3. Масштабируется через Redis Cluster или Sentinel, можно накатить репликацию.

---

## Репликация

1. Зачем: чтобы разгрузить основную базу при большом числе операций чтения и повысить устойчивость к сбоям.
2. Что имеет смысл реплицировать: AUTH (чтобы логин не падал), DOCS (для истории), PRINT (для статусов).
3. Технически это master-slave репликацию. Реализуется через PostgreSQL-репликацию, Patroni или managed-сервисы.

---

## Шардинг

1. Зачем: если система растёт, и одна БД уже не справляется - по объёму или по нагрузке.
2. Логично шардировать по user_id - это универсальный ключ, который есть почти во всех таблицах.
3. COPY не трогаем - данных немного, справочник.
4. Технически можно реализовать вручную или через Citus, Vitess и т.п.

---

## Итоговая таблица по сервисам

| Сервис | База данных        | Что храним                     | Масштабирование         |
|--------|---------------------|--------------------------------|--------------------------|
| AUTH   | PostgreSQL          | Пользователи, роли, токены     | Репликация, шардинг по user_id |
| DOCS   | PostgreSQL + S3     | Метаданные, документы          | Репликация, шардинг по user_id |
| PRINT  | PostgreSQL          | Задания на печать              | Репликация, шардинг по user_id или отделению |
| COPY   | PostgreSQL          | Отделения, статусы             | Репликация               |
| Кеш    | Redis               | Часто запрашиваемые статусы    | Redis Cluster            |

---
